<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AnuCal 2026 - Advanced</title>
    <link href="./index.css" rel="stylesheet">
</head>

<body>

    <div id="backdrop" onclick="ui.closeDrawer()"></div>

    <!-- <header>
        <h2 style="font-size: 18px;">AnuCal <span style="color:var(--text-dim)">2026</span></h2>
    </header> -->

    <div id="toolbar">
        <div id="category-wrapper">
            <div id="category-pills"></div>
            <!-- <button class="btn-icon" title="Gerenciar Categorias" onclick="ui.openDrawer('category')">⚙️</button> -->
            <button class="btn-icon" title="Gerenciar Categorias" id="btn-open-cat">⚙️</button>
        </div>
        
        <header>
            <h1 style="font-size: 18px;">AnuCal <span style="color:var(--text-dim)">2026</span></h1>
        </header>

        <!-- <button class="btn btn-primary" onclick="ui.openDrawer('event')">+ Novo Evento</button> -->
        <button class="btn btn-primary" id="btn-new-event">+ Novo Evento</button>
        <div id="login-bar">
            <button id="btn-login">Login com Google</button>
            <span id="user-name"></span>
        </div>

    </div>

    <div id="calendar-viewport">
        <div class="grid-header" id="grid-header"></div>
        <div id="grid-body"></div>
        <div id="ghost-bar" class="event-ghost"></div>
    </div>

    <div id="drawer">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
            <h3 id="drawer-title" style="font-size:18px">Editor</h3>
            <!-- <button onclick="ui.closeDrawer()" class="btn-ghost"
                style="border:none; font-size:20px; padding:4px;">&times;</button> -->
            <button id="btn-close-drawer" class="btn-ghost" style="border:none; font-size:20px; padding:4px;">&times;</button>
        </div>

        <div id="drawer-content-event" class="drawer-section">
            <input type="hidden" id="f-id">
            <label>Título</label>
            <input type="text" id="f-title" placeholder="Reunião, Viagem, etc.">

            <label>Categoria</label>
            <select id="f-cat"></select>

            <label>Repetição</label>
            <select id="f-recurrence">
                <option value="none">Não repetir</option>
                <option value="weekly">Semanalmente (toda semana)</option>
                <option value="monthly">Mensalmente (mesmo dia)</option>
            </select>
            <small style="color:var(--text-dim); font-size:11px;">Repetições são geradas apenas para este ano.</small>

            <div style="display:flex; gap:10px;">
                <div style="flex:1">
                    <label>Início</label>
                    <input type="date" id="f-start">
                </div>
                <div style="flex:1">
                    <label>Fim</label>
                    <input type="date" id="f-end">
                </div>
            </div>

            <label>Notas</label>
            <textarea id="f-desc" rows="4"></textarea>

            <div style="margin-top:24px; display:flex; flex-direction:column; gap:10px">
                <!-- <button class="btn btn-primary" onclick="app.saveEvent()">Salvar Evento</button>
                <button id="btn-delete" class="btn btn-danger" onclick="app.deleteEvent()">Excluir Evento</button> -->
                <button class="btn btn-primary" id="btn-save-event">Salvar Evento</button>
                <button id="btn-delete" class="btn btn-danger">Excluir Evento</button>
            </div>
        </div>

        <div id="drawer-content-category" class="drawer-section">
            <h4 style="margin-bottom:15px; color:var(--text-dim)">Categorias Existentes</h4>
            <div id="cat-list-editor"></div>

            <hr style="border:0; border-top:1px solid var(--border); margin: 20px 0;">

            <h4 style="margin-bottom:10px; color:white">Nova Categoria</h4>
            <label>Nome</label>
            <input type="text" id="cat-new-name" placeholder="Ex: Financeiro">
            <label>Cor</label>
            <input type="color" id="cat-new-color" value="#38bdf8" style="height:40px; width:100%">

            <!-- <button class="btn btn-primary" style="margin-top:15px; width:100%" onclick="app.addCategory()">Adicionar
                Categoria</button> -->
                <button class="btn btn-primary" id="btn-add-cat" style="margin-top:15px; width:100%">Adicionar Categoria</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithRedirect, getRedirectResult, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";


        // Your web app's Firebase configuration
        const firebaseConfig = {
            // https://console.cloud.google.com/apis/credentials?project=weber-anucal
            apiKey: "AIzaSyDbFbIj4--ni8OoKhGglw_5kBdMI0a_Rq8",
            authDomain: "weber-anucal.firebaseapp.com",
            projectId: "weber-anucal",
            storageBucket: "weber-anucal.firebasestorage.app",
            messagingSenderId: "860793722308",
            appId: "1:860793722308:web:57a0e9fb99944dedbbc091"
        };

        // Initialize Firebase
        // const app = initializeApp(firebaseConfig);
        window.firebaseApp = initializeApp(firebaseConfig);
        window.auth = getAuth();
        window.db = getFirestore();
        window.GoogleAuthProvider = GoogleAuthProvider;
        window.signInWithRedirect = signInWithRedirect;
        window.getRedirectResult = getRedirectResult;
        // window.signInWithPopup = signInWithPopup;
        window.onAuthStateChanged = onAuthStateChanged;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDoc = getDoc;

        document.getElementById("btn-login").addEventListener("click", loginGoogle);

    
        // async function loginGoogle() {
        //     const provider = new GoogleAuthProvider();
        //     const result = await signInWithPopup(auth, provider);
        // }
        // 1. Função de Login ajustada para Redirect
        async function loginGoogle() {
            try {
                const provider = new GoogleAuthProvider();
                // Força a seleção de conta para evitar logins automáticos indesejados
                provider.setCustomParameters({ prompt: 'select_account' });
                await signInWithRedirect(auth, provider);
            } catch (error) {
                console.error("Erro ao iniciar login:", error);
            }
        }

        // 2. Observador de estado robusto
        onAuthStateChanged(auth, async (user) => {
            // Verifica se houve um resultado de redirecionamento (caso o usuário tenha acabado de voltar do Google)
            const result = await getRedirectResult(auth);

            // Se não há usuário logado agora e nem resultado de redirecionamento, encerra.
            if (!user && !result?.user) return;

            // Garante que temos a instância correta do usuário
            const currentUser = user || result.user;

            // Atualiza a UI
            document.getElementById('user-name').innerText = currentUser.displayName;
            document.getElementById('btn-login').style.display = 'none'; // Esconde botão após login

            // Lógica do Firestore
            const ref = doc(db, "users", currentUser.uid);
            const snap = await getDoc(ref);

            if (snap.exists()) {
                // CARREGA DO BANCO
                Object.assign(state, snap.data().state);
                ui.renderData();
            } else {
                // PRIMEIRO LOGIN → SALVA DEFAULT
                await setDoc(ref, { state: state });
                ui.renderData(); // Renderiza mesmo se for novo
            }
        });

        async function saveState() {
            const user = auth.currentUser;
            if (!user) return;

            const ref = doc(db, "users", user.uid);
            await setDoc(ref, {
                state: state
            });
        }




        // --- 1. STATE & DATA ---
        const state = {
            year: 2026,
            categories: [
                { id: 'c1', name: 'Trabalho', color: '#3b82f6', active: true },
                { id: 'c2', name: 'Pessoal', color: '#10b981', active: true },
                { id: 'c3', name: 'Urgente', color: '#ef4444', active: true }
            ],
            events: [
                {
                    id: 'e1',
                    title: 'Projeto Q1',
                    catId: 'c1',
                    start: '2026-01-15',
                    end: '2026-01-20',
                    recurrence: 'none',
                    description: 'Fase inicial',
                    z: 0
                },
                {
                    id: 'e2',
                    title: 'Academia',
                    catId: 'c2',
                    start: '2026-01-05',
                    end: '2026-01-05',
                    recurrence: 'weekly', // Teste de repetição
                    description: 'Treino de perna',
                    z: 1
                }
            ],
            drag: {
                active: false,
                eventId: null,
                type: null,
                startX: 0,
                startY: 0,
                moved: false,
                origStart: null,
                origEnd: null
            }

        };

        // --- 2. DATE HELPERS ---
        const D = {
            parse: (s) => {
                const [y, m, d] = s.split('-').map(Number);
                return new Date(y, m - 1, d);
            },
            format: (d) => {
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            },
            diffDays: (d1, d2) => Math.round((d2 - d1) / (1000 * 60 * 60 * 24)),
            addDays: (d, n) => new Date(d.getFullYear(), d.getMonth(), d.getDate() + n),
            daysInMonth: (y, m) => new Date(y, m + 1, 0).getDate(),
            getWeekdayShort: (d) => {
                const days = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'];
                return days[d.getDay()];
            },
            isWeekend: (y, m, d) => {
                const day = new Date(y, m, d).getDay();
                return day === 0 || day === 6;
            }
        };

        // --- 3. GEOMETRY & GRID ---
        const Grid = {
            getDateFromPoint(x, y) {
                const rows = document.querySelectorAll('.month-row');

                for (let row of rows) {
                    const rect = row.getBoundingClientRect();
                    if (y < rect.top || y > rect.bottom) continue;

                    const monthIdx = parseInt(row.dataset.month);
                    const daysRow = row.querySelector('.days-row');
                    const r = daysRow.getBoundingClientRect();

                    const cellWidth = r.width / 37;
                    const col = Math.floor((x - r.left) / cellWidth);

                    if (col < 0 || col >= 37) return null;

                    const firstWeekday =
                        (new Date(state.year, monthIdx, 1).getDay() + 6) % 7;

                    const day = col - firstWeekday + 1;
                    const maxDays = D.daysInMonth(state.year, monthIdx);

                    if (day < 1 || day > maxDays) return null;

                    return new Date(state.year, monthIdx, day);
                }
                return null;
            }

        };

        // --- 4. APP LOGIC ---
        const app = {
            init() {
                ui.renderStructure();
                ui.renderData();
                this.setupDragDrop();
            },

            bindEvents() {
                // Toolbar e Gerais
                document.getElementById('btn-new-event').addEventListener('click', () => ui.openDrawer('event'));
                document.getElementById('btn-open-cat').addEventListener('click', () => ui.openDrawer('category'));
                document.getElementById('btn-close-drawer').addEventListener('click', () => ui.closeDrawer());
                document.getElementById('backdrop').addEventListener('click', () => ui.closeDrawer());

                // Ações de Eventos
                document.getElementById('btn-save-event').addEventListener('click', () => this.saveEvent());
                document.getElementById('btn-delete').addEventListener('click', () => this.deleteEvent());

                // Ações de Categorias
                document.getElementById('btn-add-cat').addEventListener('click', () => this.addCategory());

                // Eventos Delegados (para itens criados dinamicamente como Pills e Botões Excluir Cat)
                // Como esses itens são renderizados várias vezes, usamos delegação de evento no container pai

                document.getElementById('category-pills').addEventListener('click', (e) => {
                    const pill = e.target.closest('.pill');
                    if (pill) {
                        const id = state.categories[Array.from(pill.parentNode.children).indexOf(pill)].id; // ou use data-id
                        // Melhor prática: adicionar data-id no renderPills e ler aqui
                    }
                });
            },

            // --- Categories ---
            addCategory() {
                const name = document.getElementById('cat-new-name').value;
                const color = document.getElementById('cat-new-color').value;
                if (!name) return alert("Nome necessário");

                state.categories.push({
                    id: 'c-' + Date.now(),
                    name, color, active: true
                });
                document.getElementById('cat-new-name').value = '';

                ui.renderCategoryEditorList(); // Atualizar lista no editor
                ui.renderPills(); // Atualizar toolbar
                ui.renderEvents(); // Atualizar cores eventos
                saveState();
            },

            deleteCategory(id) {
                if (confirm("Tem certeza? Eventos desta categoria perderão a cor.")) {
                    state.categories = state.categories.filter(c => c.id !== id);
                    ui.renderCategoryEditorList();
                    ui.renderPills();
                    ui.renderEvents();
                    saveState();
                }
            },

            toggleCategory(id) {
                const cat = state.categories.find(c => c.id === id);
                if (cat) cat.active = !cat.active;
                ui.renderData();
                saveState();
            },

            // --- Events ---
            saveEvent() {
                const id = document.getElementById('f-id').value;
                const title = document.getElementById('f-title').value;
                const start = document.getElementById('f-start').value;
                const end = document.getElementById('f-end').value;
                const catId = document.getElementById('f-cat').value;
                const recurrence = document.getElementById('f-recurrence').value;
                const desc = document.getElementById('f-desc').value;

                if (!title || !start || !end) return alert("Título e Datas são obrigatórios");
                if (new Date(start) > new Date(end)) return alert("Data final deve ser maior que inicial");

                // Se o ID contiver "_rep_", significa que estamos editando uma ocorrência
                // Para simplificar este demo, se editar uma ocorrência, cria um novo evento separado
                let saveId = id;
                if (id && id.includes('_rep_')) {
                    saveId = ''; // Força criação de novo evento
                }

                if (saveId) {
                    const ev = state.events.find(e => e.id === saveId);
                    Object.assign(ev, { title, start, end, catId, recurrence, description: desc });
                } else {
                    state.events.push({
                        id: 'evt-' + Date.now(),
                        title, start, end, catId, recurrence, description: desc
                    });
                }
                ui.closeDrawer();
                ui.renderData();
                saveState();
            },

            deleteEvent() {
                const id = document.getElementById('f-id').value;
                if (!id) return;

                // Se for repetição, deletar (neste demo simples) não faz nada no pai
                // Em app real, perguntaria "Deletar série ou ocorrência?"
                if (id.includes('_rep_')) {
                    alert("Você não pode deletar uma única ocorrência neste demo. Edite o evento original.");
                    return;
                }

                state.events = state.events.filter(e => e.id !== id);
                ui.closeDrawer();
                ui.renderData();
                saveState();
            },

            handleCellClick(dateStr) {
                // Abre modal de criação com data pré-selecionada
                ui.openDrawer('event');
                document.getElementById('f-start').value = dateStr;
                document.getElementById('f-end').value = dateStr;
                document.getElementById('drawer-title').innerText = 'Novo Evento';
            },

            // --- Recurrence Logic (Expansion) ---
            expandEvents(events) {
                let expanded = [];
                const yearEnd = new Date(state.year, 11, 31);

                events.forEach(ev => {
                    // Adiciona o original
                    expanded.push(ev);

                    if (ev.recurrence === 'none') return;

                    const startObj = D.parse(ev.start);
                    const endObj = D.parse(ev.end);
                    const duration = D.diffDays(startObj, endObj);

                    let currStart = new Date(startObj);

                    // Loop para gerar ocorrências até o fim do ano
                    while (true) {
                        if (ev.recurrence === 'weekly') {
                            currStart.setDate(currStart.getDate() + 7);
                        } else if (ev.recurrence === 'monthly') {
                            currStart.setMonth(currStart.getMonth() + 1);
                        }

                        if (currStart > yearEnd) break;

                        // Criar clone virtual
                        const newEnd = D.addDays(currStart, duration);

                        expanded.push({
                            ...ev,
                            id: ev.id + '_rep_' + currStart.getTime(), // ID Virtual único
                            start: D.format(currStart),
                            end: D.format(newEnd),
                            isRecurringInstance: true
                        });
                    }
                });
                saveState();
                return expanded;
            },

            // --- Drag System ---
            setupDragDrop() {
                window.addEventListener('mousedown', e => {
                    const el = e.target;
                    if (el.classList.contains('handle') || el.closest('.event-bar')) {
                        const bar = el.closest('.event-bar');
                        const eventId = bar.dataset.id;

                        // Bloquear arrastar ocorrências virtuais para simplificar
                        if (eventId.includes('_rep_')) return;

                        const ev = state.events.find(e => e.id === eventId);
                        if (!ev) return;

                        state.drag.active = true;
                        state.drag.eventId = eventId;
                        state.drag.startX = e.clientX;
                        state.drag.startY = e.clientY;
                        state.drag.moved = false;

                        state.drag.origStart = D.parse(ev.start);
                        state.drag.origEnd = D.parse(ev.end);

                        state.drag.type = el.classList.contains('handle-l') ? 'resize-l' :
                            el.classList.contains('handle-r') ? 'resize-r' : 'move';

                        document.body.style.cursor = state.drag.type === 'move' ? 'grabbing' : 'ew-resize';
                        document.querySelectorAll(`.event-bar[data-id="${eventId}"]`).forEach(b => b.classList.add('dragging'));
                    }
                });

                window.addEventListener('mousemove', e => {
                    if (Math.abs(e.clientX - state.drag.startX) > 3 || Math.abs(e.clientY - state.drag.startY) > 3) {
                        state.drag.moved = true;
                    }

                    if (!state.drag.active) return;
                    e.preventDefault();

                    const currentMouseDate = Grid.getDateFromPoint(e.clientX, e.clientY);
                    const ev = state.events.find(e => e.id === state.drag.eventId);
                    if (!ev) return;

                    // --- 1. Movimentação Horizontal (Data) ---
                    if (currentMouseDate) {
                        if (state.drag.type === 'move') {
                            const duration = D.diffDays(state.drag.origStart, state.drag.origEnd);
                            let newStart = currentMouseDate;
                            const newEnd = D.addDays(newStart, duration);
                            ev.start = D.format(newStart);
                            ev.end = D.format(newEnd);
                        } else if (state.drag.type === 'resize-l') {
                            if (currentMouseDate <= D.parse(ev.end)) ev.start = D.format(currentMouseDate);
                        } else if (state.drag.type === 'resize-r') {
                            if (currentMouseDate >= D.parse(ev.start)) ev.end = D.format(currentMouseDate);
                        }
                    }

                    // --- 2. Reordenação Vertical (Slots) ---
                    // Identificamos em qual mês o mouse está para saber a altura base
                    const rows = document.querySelectorAll('.month-row');
                    let targetRow = null;
                    for (let row of rows) {
                        const rect = row.getBoundingClientRect();
                        if (e.clientY >= rect.top && e.clientY <= rect.bottom) {
                            targetRow = row;
                            break;
                        }
                    }

                    if (targetRow && state.drag.type === 'move') {
                        const daysRow = targetRow.querySelector('.days-row');
                        const rect = daysRow.getBoundingClientRect();
                        const relativeY = e.clientY - rect.top - 24; // 24 é o offset do topo (dia da célula)
                        const targetSlot = Math.max(0, Math.floor(relativeY / 28)); // 28 é a altura de cada slot

                        // Reordenar o array state.events
                        const currentIndex = state.events.findIndex(item => item.id === ev.id);

                        // Esta lógica "puxa" o evento para cima ou para baixo no array
                        // comparando o slot alvo com a ordem atual
                        if (currentIndex !== -1) {
                            state.events.splice(currentIndex, 1);
                            // Inserimos em uma posição baseada no targetSlot
                            // Para subir (ficar em cima), ele deve vir primeiro no array
                            state.events.splice(targetSlot, 0, ev);
                        }
                    }

                    requestAnimationFrame(() => ui.renderEvents());
                });

                window.addEventListener('mouseup', () => {
                    if (state.drag.active && !state.drag.moved) {
                        ui.openDrawer('event', state.drag.eventId);
                    }

                    if (state.drag.active) {
                     
                        state.drag.active = false;
                        document.body.style.cursor = 'default';

                        // Remove a classe de arraste visual
                        document.querySelectorAll('.event-bar').forEach(b => b.classList.remove('dragging'));

                        ui.renderEvents();
                    }
                });
            }
        };

        // --- 5. UI RENDERER ---
        const ui = {
            renderStructure() {
                const header = document.getElementById('grid-header');
                const week = ['Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb', 'Dom'];

                // Aumentar para 37 colunas no cabeçalho
                let hHtml = '';
                for (let i = 0; i < 37; i++) {
                    hHtml += `<div class="header-cell">${week[i % 7]}</div>`;
                }
                header.innerHTML = hHtml;

                const body = document.getElementById('grid-body');
                const months = ["JAN", "FEV", "MAR", "ABR", "MAI", "JUN", "JUL", "AGO", "SET", "OUT", "NOV", "DEZ"];

                body.innerHTML = months.map((m, idx) => {
                    let cellsHtml = '';
                    const daysInMonth = D.daysInMonth(state.year, idx);
                    const firstWeekday = (new Date(state.year, idx, 1).getDay() + 6) % 7;
                    let dayCounter = 1;

                    // Renderizar até 37 colunas para caber o offset + 31 dias
                    for (let col = 0; col < 37; col++) {
                        if (col < firstWeekday || dayCounter > daysInMonth) {
                            cellsHtml += `<div class="cell empty" style="border:none; cursor:default;"></div>`;
                        } else {
                            const dateObj = new Date(state.year, idx, dayCounter);
                            const isWk = D.isWeekend(state.year, idx, dayCounter);
                            const dateStr = D.format(dateObj);
                            const isToday = new Date().toDateString() === dateObj.toDateString();

                            cellsHtml += `
                    <div class="cell ${isWk ? 'weekend' : ''}" onclick="app.handleCellClick('${dateStr}')">
                        <div class="cell-label ${isToday ? 'today' : ''}">
                            <strong>${dayCounter}</strong>
                        </div>
                    </div>`;
                            dayCounter++;
                        }
                    }
                    return `<div class="month-row" data-month="${idx}"><div class="month-name">${m}</div><div class="days-row">${cellsHtml}</div></div>`;
                }).join('');
            },

            renderData() {
                this.renderPills();
                this.renderEvents();
            },

            renderPills() {
                const c = document.getElementById('category-pills');
                c.innerHTML = state.categories.map(cat => `
                    <div class="pill ${cat.active ? 'active' : ''}" onclick="app.toggleCategory('${cat.id}')">
                        <span class="dot" style="background:${cat.color}"></span> ${cat.name}
                    </div>
                `).join('');
            },

            renderCategoryEditorList() {
                const list = document.getElementById('cat-list-editor');
                list.innerHTML = state.categories.map(c => `
                    <div class="cat-item">
                        <div style="width:16px; height:16px; border-radius:50%; background:${c.color}"></div>
                        <span style="flex:1; font-size:13px">${c.name}</span>
                        <button class="btn-ghost" style="padding:2px 6px; font-size:10px" onclick="app.deleteCategory('${c.id}')">Excluir</button>
                    </div>
                `).join('');
            },

            renderEvents() {
                // Limpar visual antigo
                document.querySelectorAll('.event-bar').forEach(e => e.remove());
                document.querySelectorAll('.month-row').forEach(r => r.style.height = '56px'); // Reset altura mínima

                const activeCatIds = state.categories.filter(c => c.active).map(c => c.id);

                // 1. Expandir eventos recorrentes (Virtualização)
                const expandedEvents = app.expandEvents(state.events);

                // 2. Filtrar categorias ativas
                const visibleEvents = expandedEvents.filter(e => activeCatIds.includes(e.catId));

                // Processar cada mês
                for (let m = 0; m < 12; m++) {
                    const monthStart = new Date(state.year, m, 1);
                    const monthEnd = new Date(state.year, m, D.daysInMonth(state.year, m));

                    const monthEvents = visibleEvents.filter(ev => {
                        const s = D.parse(ev.start);
                        const e = D.parse(ev.end);
                        return s <= monthEnd && e >= monthStart;
                    });

                    if (monthEvents.length === 0) continue;

                    // Stacking Logic
                    // monthEvents.sort((a, b) => D.parse(a.start) - D.parse(b.start));
                    const slots = [];

                    const rowEl = document.querySelector(`.month-row[data-month="${m}"]`);
                    const container = rowEl.querySelector('.days-row');

                    monthEvents.forEach(ev => {
                        const globalStart = D.parse(ev.start);
                        const globalEnd = D.parse(ev.end);
                        const visualStart = globalStart < monthStart ? monthStart : globalStart;
                        const visualEnd = globalEnd > monthEnd ? monthEnd : globalEnd;

                        const startDay = visualStart.getDate();
                        const endDay = visualEnd.getDate();
                        const duration = endDay - startDay + 1;

                        let slotIndex = 0;
                        while (true) {
                            if (!slots[slotIndex] || startDay > slots[slotIndex]) {
                                slots[slotIndex] = endDay;
                                break;
                            }
                            slotIndex++;
                        }

                        // Render Bar
                        const bar = document.createElement('div');
                        bar.className = 'event-bar';
                        if (ev.isRecurringInstance) bar.classList.add('is-recurring');
                        if (state.drag.active && state.drag.eventId === ev.id) bar.classList.add('dragging');

                        bar.dataset.id = ev.id;
                        bar.innerHTML = ev.title; // Usar innerHTML para permitir ícones se necessário

                        const cat = state.categories.find(c => c.id === ev.catId);
                        bar.style.backgroundColor = cat ? cat.color : '#666';

                        // Math: 31 columns fixed
                        // const unit = 100 / 31;
                        // bar.style.left = `calc(${(startDay - 1) * unit}% + 2px)`;
                        // bar.style.width = `calc(${duration * unit}% - 4px)`;

                        const unit = 100 / 37;

                        // offset real do mês (Seg = 0)
                        const firstWeekday =
                            (new Date(state.year, m, 1).getDay() + 6) % 7;

                        // posição visual considerando offset
                        const visualStartCol = firstWeekday + (startDay - 1);

                        bar.style.left = `calc(${visualStartCol * unit}% + 2px)`;
                        bar.style.width = `calc(${duration * unit}% - 4px)`;

                        bar.style.top = `${(slotIndex * 28) + 24}px`; // Offset aumentado por causa do dia na célula

                        // Handles (somente para eventos originais ou lógica mais complexa)
                        if (!ev.isRecurringInstance) {
                            if (globalStart >= monthStart) {
                                const hl = document.createElement('div'); hl.className = 'handle handle-l'; bar.appendChild(hl);
                            }
                            if (globalEnd <= monthEnd) {
                                const hr = document.createElement('div'); hr.className = 'handle handle-r'; bar.appendChild(hr);
                            }
                        }

                        bar.addEventListener('click', (e) => {
                            e.stopPropagation(); // Evitar clique na célula
                            if (!e.target.classList.contains('handle') && !state.drag.active) {
                                ui.openDrawer('event', ev.id);
                            }
                        });

                        container.appendChild(bar);
                    });

                    // Resize linha se necessário
                    const requiredHeight = (slots.length * 28) + 45;
                    if (requiredHeight > 80) rowEl.style.height = requiredHeight + 'px';
                }

                saveState();
            },

            // --- Drawer ---
            openDrawer(type, id = null) {
                const d = document.getElementById('drawer');
                const back = document.getElementById('backdrop');

                // Toggle sections
                document.querySelectorAll('.drawer-section').forEach(el => el.classList.remove('active'));

                if (type === 'event') {
                    document.getElementById('drawer-content-event').classList.add('active');
                    document.getElementById('drawer-title').innerText = 'Novo Evento';

                    // Populate Selects
                    const catSel = document.getElementById('f-cat');
                    catSel.innerHTML = state.categories.map(c => `<option value="${c.id}">${c.name}</option>`).join('');

                    // Reset Inputs
                    document.getElementById('f-id').value = '';
                    document.getElementById('f-title').value = '';
                    document.getElementById('f-recurrence').value = 'none';
                    document.getElementById('f-desc').value = '';
                    document.getElementById('btn-delete').style.display = 'none';

                    if (id) {
                        // Buscar evento (pode ser instância virtual ou real)
                        // Se for virtual, precisamos achar o pai ou tratar como clone
                        let ev = state.events.find(e => e.id === id);

                        // Se não achou pelo ID exato, verifica se é uma instância recorrente (id_pai_rep_timestamp)
                        if (!ev && id.includes('_rep_')) {
                            const parentId = id.split('_rep_')[0];
                            ev = state.events.find(e => e.id === parentId);
                            // Preencher com as datas da ocorrência clicada, não do pai
                            const instanceStart = id.split('_rep_')[1]; // timestamp
                            // Isto é complexo para este demo. Vamos simplificar: abre o pai.
                            alert("Editando a série original do evento recorrente.");
                        }

                        if (ev) {
                            document.getElementById('drawer-title').innerText = 'Editar Evento';
                            document.getElementById('f-id').value = ev.id;
                            document.getElementById('f-title').value = ev.title;
                            document.getElementById('f-start').value = ev.start;
                            document.getElementById('f-end').value = ev.end;
                            document.getElementById('f-cat').value = ev.catId;
                            document.getElementById('f-recurrence').value = ev.recurrence || 'none';
                            document.getElementById('f-desc').value = ev.description || '';
                            document.getElementById('btn-delete').style.display = 'block';
                        }
                    } else {
                        // Padrão data de hoje se não veio do clique
                        if (!document.getElementById('f-start').value) {
                            const today = D.format(new Date());
                            document.getElementById('f-start').value = today;
                            document.getElementById('f-end').value = today;
                        }
                    }

                } else if (type === 'category') {
                    document.getElementById('drawer-content-category').classList.add('active');
                    document.getElementById('drawer-title').innerText = 'Gerenciar Categorias';
                    this.renderCategoryEditorList();
                }

                d.classList.add('open');
                back.classList.add('visible');
            },

            closeDrawer() {
                document.getElementById('drawer').classList.remove('open');
                document.getElementById('backdrop').classList.remove('visible');
            }
        };

        window.app = app;
        window.ui = ui;
        window.loginGoogle = loginGoogle;

        app.init();
    </script>
</body>

</html>